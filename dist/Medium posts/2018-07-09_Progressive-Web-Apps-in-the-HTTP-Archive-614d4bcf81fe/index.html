<p>Thomas Steiner, Google Hamburg, Germany</p>
<p>üìß <a href="mailto:tomac@google.com">tomac@google.com</a> ‚Ä¢ üê¶ <a href="https://twitter.com/tomayac">@tomayac</a> ‚Ä¢ üò∏ <a href="https://github.com/tomayac">tomayac</a></p>
<p>(Originally published on my blog: <a href="https://blog.tomayac.com/2018/07/09/progressive-web-apps-in-the-http-archive-143748">https://blog.tomayac.com/2018/07/09/progressive-web-apps-in-the-http-archive-143748</a>.)</p>
<h3>Abstract</h3>
<p><em>In this document, we present three different approaches and discuss their particular pros and cons for extracting data about Progressive Web Apps (PWA) from the HTTP Archive. Approach 1 is based on data that is tracked in the context of runs of the Lighthouse tool, Approach 2 is based on use counters in the Chrome browser to record per-page anonymous aggregated metrics on feature usage, and Approach 3 is based on parsing the source code of web pages for traces of service worker registrations and Web App Manifest references. We find that by all three approaches the popularity of PWAs increases roughly linearly over time and provide further research ideas based on the extracted data, whose underlying queries we share publicly.</em></p>
<h3>Introduction to Progressive Web¬†Apps</h3>
<p>Progressive Web Apps (PWA) are a new class of web applications, enabled for the most part by the <a href="https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API">Service Worker APIs</a>. Service workers allow apps to support <em>network-independent loading</em> by intercepting network requests to deliver programmatic or cached responses, service workers can receive <em>push notifications</em> and <em>synchronize</em> data in the background even when the corresponding app is not running, and service workers‚Ää‚Äî‚Äätogether with <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">Web App Manifests</a>‚Ää‚Äî‚Ääallow users to <em>install</em> PWAs to their devices‚Äô home screens. Service workers were <a href="https://blog.chromium.org/2014/12/chrome-40-beta-powerful-offline-and.html">first implemented in Chrome 40 Beta</a> released in December 2014, and the term <em>Progressive Web Apps</em> was <a href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/">coined by Frances Berriman and Alex Russell</a> in 2015.</p>
<h3>Research Questions and Problem Statement</h3>
<p>As service workers are now finally <a href="https://jakearchibald.github.io/isserviceworkerready/">implemented in all major browsers</a>, we at the Google Web Developer Relations team were wondering <em>‚Äúhow many PWAs are actually out there in the wild and how do they make use of these new technologies?‚Äù</em> Certain advanced APIs like <a href="https://developers.google.com/web/updates/2015/12/background-sync">Background Sync</a> are currently still <a href="https://caniuse.com/#feat=background-sync">only available on Chromium-based browsers</a>, so as an additional question we looked into <em>‚Äúwhat features do these PWAs actually use‚Ää‚Äî‚Ääor in the sense of progressive enhancement‚Ää‚Äî‚Äätry to use?‚Äù</em> Our first idea was to check some of the curated PWA catalogues, for example, <a href="https://pwa.rocks/">PWA.rocks</a>, <a href="https://pwa-directory.appspot.com/">PWA Directory</a>, <a href="https://outweb.io/">Outweb</a>, or <a href="https://www.pwastats.com/">PWA Stats</a>. The problem with such catalogues is that they suffer from what we call <em>submission bias</em>. <a href="https://outweb.io/1506520224205">Anecdotal</a> <a href="https://www.pwastats.com/2017/06/forbes/">evidence</a> <a href="https://pwa-directory.appspot.com/pwas/5758305695694848">shows</a> that authors of PWAs want to be included in as many catalogues as possible, but oftentimes the listed examples are not very representative of <em>the</em> web and rather longtail. For example, at the time of writing, the <a href="https://pwa-directory.appspot.com/pwas/4816176644358144">first listed PWA</a> on <em>PWA Directory</em> is <a href="https://feuerwehr-eisolzried.de/">feuerwehr-eisolzried.de</a>, a PWA on the <em>‚Äúlatest news, dates and more from [the] fire department in Eisolzried, Bavaria.‚Äù</em> Second, while <em>PWA Stats</em> offers tags, for example, on the <a href="https://www.pwastats.com/tags/notifications">use of notifications</a>, not all PWA features are classified in their tagging system. In short, PWA catalogues are not very well suited for answering our research questions.</p>
<h3>The HTTP Archive to the¬†Rescue</h3>
<p>The <a href="https://httparchive.org/">HTTP Archive</a> tracks how the web is built and provides historical data to quantitatively illustrate how the web is evolving. The archive‚Äôs crawlers process <a href="https://httparchive.org/faq#how-does-the-http-archive-decide-which-urls-to-test">500,000 URLs</a> for both desktop and mobile twice a month. These URLs come from the most popular 500,000 sites in the <a href="http://www.alexa.com/topsites">Alexa Top 1,000,000</a> list and are mostly homepages that may or may not be representative for the rest of the site. The data in the HTTP Archive can be <a href="https://github.com/HTTPArchive/legacy.httparchive.org/blob/master/docs/bigquery-gettingstarted.md">queried through BigQuery</a>, where multiple tables are available in the <code>httparchive</code> project. As these tables tend to get fairly big, they are partitioned, but multiple associated tables can be queried using the <a href="https://cloud.google.com/bigquery/docs/querying-wildcard-tables">wildcard symbol '*'</a>. For our purposes, three families of tables are relevant, leading to three different approaches:</p>
<ul>
<li><code>httparchive.lighthouse.*</code>, which contains data about <a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse</a> runs.</li>
<li><code>httparchive.pages.*</code>, which contain the JSON-encoded parent documents‚Äô <a href="https://w3c.github.io/web-performance/specs/HAR/Overview.html">HAR</a> data.</li>
<li><code>httparchive.response_bodies.*</code>, which contains the raw response bodies of all resources and sub-resources of all sites in the archive.</li>
</ul>
<p>In the following, we will discuss all three approaches and their particular pros and cons, as well as present the extractable data and ideas for further research. All <a href="https://github.com/tomayac/http-archive-progressive-web-apps">queries are also available on GitHub</a> and are released under the terms of the Apache 2.0 license.</p>
<p>‚ö†Ô∏è Warning: while BigQuery grants everyone a certain amount of <a href="https://cloud.google.com/bigquery/pricing#free">free quota per month</a>, on-demand pricing kicks in once the free quota is consumed. Currently, this is <a href="https://cloud.google.com/bigquery/pricing#on_demand_pricing">$5 per terabyte</a>. Some of the shown queries process 70+(!) terabytes! You can see the amount of data that will be processed by clicking on the <em>Validator</em> icon:</p>
<p><img src="img/0____cfd3gLaYKT5ekIu.png" alt=""></p>
<h3>Approach 1: <code>httparchive.lighthouse.*</code> Tables</h3>
<h3>Description</h3>
<p><a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse</a> is an automated open-source tool for improving the quality of web pages. One can run it against any web page, public or requiring authentication. It has audits for <em>Performance</em>, <em>Accessibility</em>, <em>Progressive Web App</em>, and more. The <code>httparchive.lighthouse.*</code> tables contain JSON dumps (<a href="https://gist.github.com/tomayac/05fed2d4bfa94fe066c705510a3c2103">example</a>) of past reports that can be extracted via BigQuery.</p>
<h3>Cons</h3>
<p>The biggest con is that obviously the tables only contain data of web pages that were ever run through the tool, so there is a blind spot. Additionally, while latest versions of Lighthouse process mobile <em>and</em> desktop pages, the currently used Lighthouse only processes mobile pages, so there are no results for desktop. One pitfall when working with these tables is that in a past version of Lighthouse <em>Progressive Web App</em> was the first category that was shown in the tool, however the <a href="https://github.com/GoogleChrome/lighthouse/issues/3599">order was flipped</a> in the current version so that now <em>Performance</em> is first. In the query we need to take this corner case into account.</p>
<h3>Pros</h3>
<p>On the positive side, Lighthouse has clear scoring guidelines based on the <a href="https://developers.google.com/web/progressive-web-apps/checklist#baseline">Baseline PWA Checklist</a> for each version of the tool (<a href="https://developers.google.com/web/tools/lighthouse/scoring#pwa">v2</a>, <a href="https://developers.google.com/web/tools/lighthouse/v3/scoring#pwa">v3</a>), so by requiring a minimum <em>Progressive Web App</em> score of ‚â•75, we can, to some extent, determine what PWA features we want to have included, namely, we can require offline capabilities and make sure the app can be added to the home screen.</p>
<h3>Query and¬†Results</h3>
<p>Running the query below and then selecting distinct PWA URLs returns <a href="https://docs.google.com/spreadsheets/d/1zxpfuEW06oG6wXWq96Zrs0FjzDVVDUTpRcNu9TkiyIw/edit?usp=sharing">799 unique PWA results</a> that are known to work offline and to be installable to the user‚Äôs home screen.</p>
<p>#standardSQL<br>
CREATE TEMPORARY FUNCTION<br>
getPWAScore(report STRING)<br>
RETURNS FLOAT64<br>
LANGUAGE js AS &quot;&quot;&quot;<br>
$=JSON.parse(report);<br>
return $.reportCategories.find(i =&gt; i.name === 'Progressive Web App').score;<br>
&quot;&quot;&quot;;<br>
CREATE TABLE IF NOT EXISTS<br>
`progressive_web_apps.lighthouse_pwas` AS<br>
SELECT<br>
DISTINCT url AS pwa_url,<br>
IFNULL(rank,<br>
1000000) AS rank,<br>
date,<br>
platform,<br>
CAST(ROUND(score) AS INT64) AS lighthouse_pwa_score<br>
FROM (<br>
SELECT<br>
REGEXP_REPLACE(JSON_EXTRACT(report,<br>
&quot;$.url&quot;), &quot;\&quot;&quot;, &quot;&quot;) AS url,<br>
getPWAScore(report) AS score,<br>
REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;\\d{4}(?:_\\d{2}){2}&quot;), &quot;_&quot;, &quot;-&quot;) AS date,<br>
REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;.*_(\\w+)$&quot;) AS platform<br>
FROM<br>
`httparchive.lighthouse.*`<br>
WHERE<br>
report IS NOT NULL<br>
AND JSON_EXTRACT(report,<br>
&quot;$.audits.service-worker.score&quot;) = 'true' )<br>
LEFT JOIN (<br>
SELECT<br>
Alexa_rank AS rank,<br>
Alexa_domain AS domain<br>
FROM<br>
# Hard-coded due to <a href="https://github.com/HTTPArchive/bigquery/issues/42">https://github.com/HTTPArchive/bigquery/issues/42</a><br>
`httparchive.urls.20170315`<br>
WHERE<br>
Alexa_rank IS NOT NULL<br>
AND Alexa_domain IS NOT NULL ) AS urls<br>
ON<br>
urls.domain = NET.REG_DOMAIN(url)<br>
WHERE</p>
<h1>Lighthouse &quot;Good&quot; threshold</h1>
<p>score &gt;= 75<br>
GROUP BY<br>
url,<br>
date,<br>
score,<br>
platform,<br>
date,<br>
rank<br>
ORDER BY<br>
rank ASC,<br>
url,<br>
date DESC;</p>
<h3>Research Ideas</h3>
<p>An interesting analysis we can run based on this data is the development of average Lighthouse PWA scores over time and the number of PWAs (note that the presented naive approach does not take the in relation also growing HTTP Archive into account, but purely counts absolute numbers).</p>
<p>#standardSQL<br>
SELECT<br>
date,<br>
count (DISTINCT pwa_url) AS total_pwas,<br>
round(AVG(lighthouse_pwa_score), 1) AS avg_lighthouse_pwa_score<br>
FROM<br>
`progressive_web_apps.lighthouse_pwas`<br>
GROUP BY<br>
date<br>
ORDER BY<br>
date;</p>
<p><img src="img/0__2mxuOwVntHQmBKUd.png" alt="">
<img src="img/0__Wa5__01H83LHLQ4jo.png" alt=""></p>
<h3>Approach 2: <code>httparchive.pages.*</code> Tables</h3>
<h3>Description</h3>
<p>Another straightforward way for estimating the amount of PWAs (however completely neglecting Web App Manifests) is to look for so-called <a href="https://cs.chromium.org/chromium/src/third_party/blink/public/platform/web_feature.mojom">use counters</a> in the <code>httparchive.pages.*</code> tables. Particularly interesting is the <code>ServiceWorkerControlledPage</code> use counter, which, <a href="https://groups.google.com/a/chromium.org/d/msg/blink-api-owners-discuss/uxwEuxCRfGA/_1VdL4_EBAAJ">according to Chrome engineer Matt Falkenhagen</a>, <em>‚Äúis counted whenever a page is controlled by a service worker, which typically happens only on subsequent loads.‚Äù</em></p>
<h3>Cons</h3>
<p>No qualitative attributes other than the absolute fact that a service worker controlled the loading of the page can be extracted. More importantly, as the counter is typically triggered on subsequent loads only (and not on the first load that the crawler sees), this method undercounts and only contains sites that claim their clients (<code>self.clients.claim()</code>) on the first load.</p>
<h3>Pros</h3>
<p>On the bright side, the precision is high due to the browser-level tracking, so we can be sure the page actually registered a service worker. The query also covers both desktop and mobile.</p>
<h3>Query and¬†Results</h3>
<p>This approach, at time of writing, turns up <a href="https://docs.google.com/spreadsheets/d/16jJQF4ACqOKnypCC1jqUqpC3mO-guBZAaSA-P9tbJJg/edit?usp=sharing">5,368 unique results</a>, however, as mentioned before, not all of these results <em>necessarily</em> qualify as PWA due to the potentially missing Web App Manifest that affects the installability of the app.</p>
<p>#standardSQL<br>
CREATE TABLE IF NOT EXISTS<br>
`progressive_web_apps.usecounters_pwas` AS<br>
SELECT<br>
DISTINCT REGEXP_REPLACE(url, &quot;^http:&quot;, &quot;https:&quot;) AS pwa_url,<br>
IFNULL(rank,<br>
1000000) AS rank,<br>
date,<br>
platform<br>
FROM (<br>
SELECT<br>
DISTINCT url,<br>
REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;\\d{4}(?:_\\d{2}){2}&quot;), &quot;_&quot;, &quot;-&quot;) AS date,<br>
REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;.*_(\\w+)$&quot;) AS platform<br>
FROM<br>
`httparchive.pages.*`<br>
WHERE<br>
# From <a href="https://cs.chromium.org/chromium/src/third_party/blink/public/platform/web_feature.mojom">https://cs.chromium.org/chromium/src/third_party/blink/public/platform/web_feature.mojom</a><br>
JSON_EXTRACT(payload,<br>
'$._blinkFeatureFirstUsed.Features.ServiceWorkerControlledPage') IS NOT NULL)<br>
LEFT JOIN (<br>
SELECT<br>
Alexa_domain AS domain,<br>
Alexa_rank AS rank<br>
FROM<br>
# Hard-coded due to <a href="https://github.com/HTTPArchive/bigquery/issues/42">https://github.com/HTTPArchive/bigquery/issues/42</a><br>
`httparchive.urls.20170315` AS urls<br>
WHERE<br>
Alexa_rank IS NOT NULL<br>
AND Alexa_domain IS NOT NULL )<br>
ON<br>
domain = NET.REG_DOMAIN(url)<br>
ORDER BY<br>
rank ASC,<br>
date DESC,<br>
pwa_url;</p>
<h3>Research Ideas</h3>
<p>Similar to the second query in <em>Approach 1</em> from above, we can also track the number of pages controlled by a service worker over time (the gap in the September 1, 2017 dataset is due to a parsing issue in the data collection pipeline).</p>
<p>#standardSQL<br>
SELECT<br>
date,<br>
count (DISTINCT pwa_url) AS total_pwas<br>
FROM<br>
`progressive_web_apps.usecounters_pwas`<br>
GROUP BY<br>
date<br>
ORDER BY<br>
date;</p>
<p><img src="img/0__MYeN__MO1GkE3__U2f.png" alt=""></p>
<h3>Approach 3: <code>httparchive.response_body.*</code> Tables</h3>
<h3>Description</h3>
<p>A third less obvious way to answer our research questions is to look at actual response bodies. The <code>httparchive.response_bodies.*</code> tables contain raw data of all resources and sub-resources of all sites in the archive, so we can use fulltext search to find patterns that are indicators for the presence of PWA features like, for instance, the existence of variations of the string <code>navigator.serviceWorker.register(&quot;</code> that provide a clue that the page might be registering a service worker on the one hand, and variations of <code>&lt;link rel=&quot;manifest&quot;</code> that point to a potential Web App Manifest on the other hand.</p>
<h3>Cons</h3>
<p>The downside of this approach is that we are trying to parse HTML with regular expressions to begin with, which is <a href="https://stackoverflow.com/a/1732454">commonly known to be impossible</a> and a <a href="https://www.reddit.com/r/ProgrammerHumor/comments/6ytfw5/parsing_html_using_regular_expressions/">bad practice</a>. One example where things can go wrong is that we might detect out-commented code or struggle with incorrectly nested code.</p>
<h3>Pros</h3>
<p>Despite all challenges, as the service worker JavaScript files and the Web App Manifest JSON files are subresources of the page and therefore stored in the <code>httparchive.response_bodies.*</code> tables, we can still bravely attempt to examine their contents and try to gain an in-depth understanding of the PWAs‚Äô capabilities. By checking the service worker JavaScript code for the events the service worker listens to, we can see if a PWA‚Äîat least in theory‚Äîdeals with Web Push notifications, handles fetches, <em>etc.</em>, and by looking at the Web App Manifest JSON document, we can see if the PWA specifies a start URL, provides a name, and so on.</p>
<h3>Query and¬†Results</h3>
<p>We have split the analysis of service workers and Web App Manifests, and use a common helper table to extract PWA candidates from the large response body tables. As references to service worker script files and Web App Manifest JSON files may be relative or absolute, we need a <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions">User-Defined Function</a> to resolve paths like¬†<code>../../manifest.json</code> relative to their base URL. Our function is a hacky simplification based on <a href="https://nodejs.org/docs/latest/api/path.html#path_path_resolve_paths">path.resolve([...paths])</a> in Node.js and not very elegant. We deliberately ignore references that would require executing JavaScript, for example, URLs like <code>window.location.href + 'sw.js'</code>, so our regular expressions are a bit involved to make sure we exclude these cases.</p>
<h4>PWA Candidates Helper¬†Table</h4>
<p>#standardSQL<br>
CREATE TEMPORARY FUNCTION<br>
pathResolve(path1 STRING,<br>
path2 STRING)<br>
RETURNS STRING<br>
LANGUAGE js AS &quot;&quot;&quot;<br>
function normalizeStringPosix(e,t){for(var n=&quot;&quot;,r=-1,i=0,l=void 0,o=!1,h=0;h&lt;=e.length;++h){if(h&lt;e.length)l=e.charCodeAt(h);else{if(l===SLASH)break;l=SLASH}if(l===SLASH){if(r===h-1||1===i);else if(r!==h-1&amp;&amp;2===i){if(n.length&lt;2||!o||n.charCodeAt(n.length-1)!==DOT||n.charCodeAt(n.length-2)!==DOT)if(n.length&gt;2){for(var g=n.length-1,a=g;a&gt;=0&amp;&amp;n.charCodeAt(a)!==SLASH;--a);if(a!==g){n=-1===a?&quot;&quot;:n.slice(0,a),r=h,i=0,o=!1;continue}}else if(2===n.length||1===n.length){n=&quot;&quot;,r=h,i=0,o=!1;continue}t&amp;&amp;(n.length&gt;0?n+=&quot;/..&quot;:n=&quot;..&quot;,o=!0)}else{var f=e.slice(r+1,h);n.length&gt;0?n+=&quot;/&quot;+f:n=f,o=!1}r=h,i=0}else l===DOT&amp;&amp;-1!==i?++i:i=-1}return n}function resolvePath(){for(var e=[],t=0;t&lt;arguments.length;t++)e[t]=arguments[t];for(var n=&quot;&quot;,r=!1,i=void 0,l=e.length-1;l&gt;=-1&amp;&amp;!r;l--){var o=void 0;l&gt;=0?o=e[l]:(void 0===i&amp;&amp;(i=getCWD()),o=i),0!==o.length&amp;&amp;(n=o+&quot;/&quot;+n,r=o.charCodeAt(0)===SLASH)}return n=normalizeStringPosix(n,!r),r?&quot;/&quot;+n:n.length&gt;0?n:&quot;.&quot;}var SLASH=47,DOT=46,getCWD=function(){return&quot;&quot;};if(/^https?:/.test(path2)){return path2;}if(/^\\//.test(path2)){return path1+path2.substr(1);}return resolvePath(path1, path2).replace(/^(https?:\\/)/, '$1/');<br>
&quot;&quot;&quot;;<br>
CREATE TABLE IF NOT EXISTS<br>
`progressive_web_apps.pwa_candidates` AS<br>
SELECT<br>
DISTINCT REGEXP_REPLACE(page, &quot;^http:&quot;, &quot;https:&quot;) AS pwa_url,<br>
IFNULL(rank,<br>
1000000) AS rank,<br>
pathResolve(REGEXP_REPLACE(page, &quot;^http:&quot;, &quot;https:&quot;),<br>
REGEXP_EXTRACT(body, &quot;navigator\\.serviceWorker\\.register\\s*\\(\\s*[\&quot;']([^\\),\\s\&quot;']+)&quot;)) AS sw_url,<br>
pathResolve(REGEXP_REPLACE(page, &quot;^http:&quot;, &quot;https:&quot;),<br>
REGEXP_EXTRACT(REGEXP_EXTRACT(body, &quot;(&lt;link[^&gt;]+rel=[\&quot;']?manifest[\&quot;']?[^&gt;]+&gt;)&quot;), &quot;href=[\&quot;']?([^\\s\&quot;'&gt;]+)[\&quot;']?&quot;)) AS manifest_url<br>
FROM<br>
`httparchive.response_bodies.*`<br>
LEFT JOIN (<br>
SELECT<br>
Alexa_domain AS domain,<br>
Alexa_rank AS rank<br>
FROM<br>
# Hard-coded due to <a href="https://github.com/HTTPArchive/bigquery/issues/42">https://github.com/HTTPArchive/bigquery/issues/42</a><br>
`httparchive.urls.20170315` AS urls<br>
WHERE<br>
Alexa_rank IS NOT NULL<br>
AND Alexa_domain IS NOT NULL )<br>
ON<br>
domain = NET.REG_DOMAIN(page)<br>
WHERE<br>
(REGEXP_EXTRACT(body, &quot;navigator\\.serviceWorker\\.register\\s*\\(\\s*[\&quot;']([^\\),\\s\&quot;']+)&quot;) IS NOT NULL<br>
AND REGEXP_EXTRACT(body, &quot;navigator\\.serviceWorker\\.register\\s*\\(\\s*[\&quot;']([^\\),\\s\&quot;']+)&quot;) != &quot;/&quot;)<br>
AND (REGEXP_EXTRACT(REGEXP_EXTRACT(body, &quot;(&lt;link[^&gt;]+rel=[\&quot;']?manifest[\&quot;']?[^&gt;]+&gt;)&quot;), &quot;href=[\&quot;']?([^\\s\&quot;'&gt;]+)[\&quot;']?&quot;) IS NOT NULL<br>
AND REGEXP_EXTRACT(REGEXP_EXTRACT(body, &quot;(&lt;link[^&gt;]+rel=[\&quot;']?manifest[\&quot;']?[^&gt;]+&gt;)&quot;), &quot;href=[\&quot;']?([^\\s\&quot;'&gt;]+)[\&quot;']?&quot;) != &quot;/&quot;)<br>
ORDER BY<br>
rank ASC,<br>
pwa_url;</p>
<h4>Web App Manifests Analysis</h4>
<p>Based on this helper table, we can then run the analysis of the Web App Manifests. We check for the existence of properties defined in the <code>[WebAppManifest](https://www.w3.org/TR/appmanifest/#webappmanifest-dictionary)</code> <a href="https://www.w3.org/TR/appmanifest/#webappmanifest-dictionary">dictionary</a> combined with non-standard, but well-known properties like <code>&quot;gcm_sender_id&quot;</code> from the deprecated <a href="https://developers.google.com/cloud-messaging/">Google Cloud Messaging</a> or <code>&quot;share_target&quot;</code> from the currently <a href="https://wicg.github.io/web-share-target/#extension-to-the-web-app-manifest">in flux Web Share Target API</a>. Turns out, not many manifests are in the archive; from 2,823 candidate manifest URLs in the helper table we actually only find <a href="https://docs.google.com/spreadsheets/d/1VE9hoj7Ag7E3kOG4BKc8NKISg1w0BZVQkGdCq4MJ6hw/edit?usp=sharing">30 unique Web App Manifests</a> and thus PWAs in the response bodies, but these at least archived in several versions.</p>
<p>#standardSQL<br>
CREATE TABLE IF NOT EXISTS `progressive_web_apps.web_app_manifests` AS<br>
SELECT<br>
pwa_url,<br>
rank,<br>
manifest_url,<br>
date,<br>
platform,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;dir\&quot;\s*:&quot;) AS dir_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;lang\&quot;\s*:&quot;) AS lang_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;name\&quot;\s*:&quot;) AS name_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;short_name\&quot;\s*:&quot;) AS short_name_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;description\&quot;\s*:&quot;) AS description_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;scope\&quot;\s*:&quot;) AS scope_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;icons\&quot;\s*:&quot;) AS icons_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;display\&quot;\s*:&quot;) AS display_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;orientation\&quot;\s*:&quot;) AS orientation_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;start_url\&quot;\s*:&quot;) AS start_url_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;serviceworker\&quot;\s*:&quot;) AS serviceworker_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;theme_color\&quot;\s*:&quot;) AS theme_color_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;related_applications\&quot;\s*:&quot;) AS related_applications_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;prefer_related_applications\&quot;\s*:&quot;) AS prefer_related_applications_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;background_color\&quot;\s*:&quot;) AS background_color_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;categories\&quot;\s*:&quot;) AS categories_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;screenshots\&quot;\s*:&quot;) AS screenshots_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;iarc_rating_id\&quot;\s*:&quot;) AS iarc_rating_id_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;gcm_sender_id\&quot;\s*:&quot;) AS gcm_sender_id_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;gcm_user_visible_only\&quot;\s*:&quot;) AS gcm_user_visible_only_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;share_target\&quot;\s*:&quot;) AS share_target_property,<br>
REGEXP_CONTAINS(manifest_code,<br>
r&quot;\&quot;supports_share\&quot;\s*:&quot;) AS supports_share_property<br>
FROM<br>
`progressive_web_apps.pwa_candidates`<br>
JOIN (<br>
SELECT<br>
url,<br>
body AS manifest_code,<br>
REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;\\d{4}(?:_\\d{2}){2}&quot;), &quot;_&quot;, &quot;-&quot;) AS date,<br>
REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;.*_(\\w+)$&quot;) AS platform<br>
FROM<br>
`httparchive.response_bodies.*`<br>
WHERE<br>
body IS NOT NULL<br>
AND body != &quot;&quot;<br>
AND url IN (<br>
SELECT<br>
DISTINCT manifest_url<br>
FROM<br>
`progressive_web_apps.pwa_candidates`) ) AS manifest_bodies<br>
ON<br>
manifest_bodies.url = manifest_url<br>
ORDER BY<br>
rank ASC,<br>
pwa_url,<br>
date DESC,<br>
platform,<br>
manifest_url;</p>
<h4>Research Ideas</h4>
<p>With this data at hand, we can extract all (well, not really <em>all</em>, but all known according to our query) PWAs that still use the deprecated Google Cloud Messaging service.</p>
<p>#standardSQL<br>
SELECT<br>
DISTINCT pwa_url,<br>
manifest_url<br>
FROM<br>
`progressive_web_apps.web_app_manifests`<br>
WHERE<br>
gcm_sender_id_property;</p>
<h4>Service Workers¬†Analysis</h4>
<p>Similarly to the analysis of Web App Manifests, the analysis of the various <code>[ServiceWorkerGlobalScope](https://www.w3.org/TR/service-workers-1/#execution-context-events)</code> <a href="https://www.w3.org/TR/service-workers-1/#execution-context-events">events</a> is based on regular expressions. Events can be listened to using two JavaScript syntaxes: <em>(i)</em> the property syntax (<em>e.g.</em>, <code>self.oninstall = [‚Ä¶]</code> or <em>(ii)</em> the event listener syntax (<em>e.g.</em>, <code>self.addEventListener('install', [‚Ä¶])</code>). As an additional data point, we extract potential uses of the increasingly popular library <a href="https://developers.google.com/web/tools/workbox/">Workbox</a> by looking for telling traces of various Workbox versions in the code. Running this query we obtain <a href="https://docs.google.com/spreadsheets/d/1rrSh3tXje9WnySfX8oRafY7Aduunv6X0rq_jmcBicIM/edit?usp=sharing">1,151 unique service workers</a> and thus PWAs.</p>
<p>#standardSQL<br>
CREATE TABLE IF NOT EXISTS<br>
`progressive_web_apps.service_workers` AS<br>
SELECT<br>
pwa_url,<br>
rank,<br>
sw_url,<br>
date,<br>
platform,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.oninstall\s*=|addEventListener\(\s*[\&quot;']install[\&quot;']&quot;) AS install_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.onactivate\s*=|addEventListener\(\s*[\&quot;']activate[\&quot;']&quot;) AS activate_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.onfetch\s*=|addEventListener\(\s*[\&quot;']fetch[\&quot;']&quot;) AS fetch_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.onpush\s*=|addEventListener\(\s*[\&quot;']push[\&quot;']&quot;) AS push_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.onnotificationclick\s*=|addEventListener\(\s*[\&quot;']notificationclick[\&quot;']&quot;) AS notificationclick_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.onnotificationclose\s*=|addEventListener\(\s*[\&quot;']notificationclose[\&quot;']&quot;) AS notificationclose_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.onsync\s*=|addEventListener\(\s*[\&quot;']sync[\&quot;']&quot;) AS sync_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.oncanmakepayment\s*=|addEventListener\(\s*[\&quot;']canmakepayment[\&quot;']&quot;) AS canmakepayment_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.onpaymentrequest\s*=|addEventListener\(\s*[\&quot;']paymentrequest[\&quot;']&quot;) AS paymentrequest_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.onmessage\s*=|addEventListener\(\s*[\&quot;']message[\&quot;']&quot;) AS message_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;\.onmessageerror\s*=|addEventListener\(\s*[\&quot;']messageerror[\&quot;']&quot;) AS messageerror_event,<br>
REGEXP_CONTAINS(sw_code, r&quot;new Workbox|new workbox|workbox\.precaching\.|workbox\.strategies\.&quot;) AS uses_workboxjs<br>
FROM<br>
`progressive_web_apps.pwa_candidates`<br>
JOIN (<br>
SELECT<br>
url,<br>
body AS sw_code,<br>
REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;\\d{4}(?:_\\d{2}){2}&quot;), &quot;_&quot;, &quot;-&quot;) AS date,<br>
REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;.*_(\\w+)$&quot;) AS platform<br>
FROM<br>
`httparchive.response_bodies.*`<br>
WHERE<br>
body IS NOT NULL<br>
AND body != &quot;&quot;<br>
AND url IN (<br>
SELECT<br>
DISTINCT sw_url<br>
FROM<br>
`progressive_web_apps.pwa_candidates`) ) AS sw_bodies<br>
ON<br>
sw_bodies.url = sw_url<br>
ORDER BY<br>
rank ASC,<br>
pwa_url,<br>
date DESC,<br>
platform,<br>
sw_url;</p>
<h4>Research Ideas</h4>
<p>Having detailed service worker data allows for interesting analyses. For example, we can use this data to track Workbox usage over time.</p>
<p>#standardSQL<br>
SELECT<br>
date,<br>
count (uses_workboxjs) AS total_uses_workbox<br>
FROM<br>
`progressive_web_apps.service_workers`<br>
WHERE<br>
uses_workboxjs<br>
AND platform = 'mobile'<br>
GROUP BY<br>
date<br>
ORDER BY<br>
date;</p>
<p><img src="img/0__mEfAJbCij2INN3Y8.png" alt=""></p>
<p>Lines of code (LOC) is a great metric (<a href="https://en.wikipedia.org/wiki/Source_lines_of_code#Utility">not</a>) to estimate a team‚Äôs productivity and to predict a task‚Äôs complexity. Let‚Äôs analyze the development of a given site‚Äôs service worker in terms of string length. Seems like the team deserves a raise‚Ä¶ üòâ</p>
<p>#standardSQL<br>
SELECT<br>
DISTINCT pwa_url,<br>
sw_url,<br>
date,<br>
CHAR_LENGTH(body) AS sw_length<br>
FROM<br>
`progressive_web_apps.service_workers`<br>
JOIN<br>
`httparchive.response_bodies.*`<br>
ON<br>
sw_url = url<br>
AND date = REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;\\d{4}(?:_\\d{2}){2}&quot;), &quot;_&quot;, &quot;-&quot;)<br>
AND platform = REGEXP_EXTRACT(_TABLE_SUFFIX, &quot;.*_(\\w+)$&quot;)<br>
WHERE</p>
<h1>Redacted</h1>
<p>pwa_url = &quot;https://example.com/&quot;<br>
AND platform = &quot;mobile&quot;<br>
ORDER BY<br>
date ASC;</p>
<p><img src="img/0__aga5T3IRd7hDeA0p.png" alt=""></p>
<p>A final idea is to examine service worker events over time and see if there are interesting developments. Something that stands out in the analysis is how increasingly the <code>fetch</code> event is being listened to as well as the <code>message</code> event. Both are an indicator for more complex offline handling scenarios.</p>
<p>#standardSQL<br>
SELECT<br>
date,<br>
COUNT(IF (install_event,<br>
TRUE,<br>
NULL)) AS install_events,<br>
COUNT(IF ( activate_event,<br>
TRUE,<br>
NULL)) AS activate_events,<br>
COUNT(IF ( fetch_event,<br>
TRUE,<br>
NULL)) AS fetch_events,<br>
COUNT(IF ( push_event,<br>
TRUE,<br>
NULL)) AS push_events,<br>
COUNT(IF ( notificationclick_event,<br>
TRUE,<br>
NULL)) AS notificationclick_events,<br>
COUNT(IF ( notificationclose_event,<br>
TRUE,<br>
NULL)) AS notificationclose_events,<br>
COUNT(IF ( sync_event,<br>
TRUE,<br>
NULL)) AS sync_events,<br>
COUNT(IF ( canmakepayment_event,<br>
TRUE,<br>
NULL)) AS canmakepayment_events,<br>
COUNT(IF ( paymentrequest_event,<br>
TRUE,<br>
NULL)) AS paymentrequest_events,<br>
COUNT(IF ( message_event,<br>
TRUE,<br>
NULL)) AS message_events,<br>
COUNT(IF ( messageerror_event,<br>
TRUE,<br>
NULL)) AS messageerror_events<br>
FROM<br>
`progressive_web_apps.service_workers`<br>
WHERE<br>
NOT uses_workboxjs<br>
AND date LIKE &quot;2018-%&quot;<br>
GROUP BY<br>
date<br>
ORDER BY<br>
date;</p>
<p><img src="img/0__Qy4PNB53__ZlQPgKx.png" alt=""></p>
<h3>Meta Approach: Approaches 1‚Äì3¬†Combined</h3>
<p>An interesting meta analysis is to combine all approaches to get a feeling for the overall landscape of PWAs in the HTTP Archive (with all aforementioned pros and cons regarding precision and recall applied). If we run the query below, we find exactly <a href="https://docs.google.com/spreadsheets/d/1XcSa59AwZZiqz7QdEH6CncU6lnSgzAEAOMbyI-aHBow/edit?usp=sharing">6,647 unique PWAs</a>. They may not necessarily still be PWAs today; some of the previously very prominent PWA lighthouse cases are known to have regressed, and some were only very briefly experimenting with the technologies, but in the HTTP Archive we have evidence of the glory moment in history where all of these pages fulfilled at least one of our three approaches‚Äô criteria for being counted as a PWA.</p>
<p>#standardSQL<br>
SELECT<br>
DISTINCT pwa_url,<br>
rank<br>
FROM (<br>
SELECT<br>
DISTINCT pwa_url,<br>
rank<br>
FROM<br>
`progressive_web_apps.lighthouse_pwas` union all<br>
SELECT<br>
DISTINCT pwa_url,<br>
rank<br>
FROM<br>
`progressive_web_apps.service_workers` union all<br>
SELECT<br>
DISTINCT pwa_url,<br>
rank<br>
FROM<br>
`progressive_web_apps.usecounters_pwas`)<br>
ORDER BY<br>
rank ASC;</p>
<p>If we aggregate by dates and ignore some runaway values, we can see linear growth in the total number of PWAs, with a slight decline at the end of our observation period that we will have an eye on in future research.</p>
<p>#standardSQL<br>
SELECT<br>
DISTINCT date,<br>
COUNT(pwa_url) AS pwas<br>
FROM (<br>
SELECT<br>
DISTINCT date,<br>
pwa_url<br>
FROM<br>
`progressive_web_apps.lighthouse_pwas`<br>
UNION ALL<br>
SELECT<br>
DISTINCT date,<br>
pwa_url<br>
FROM<br>
`progressive_web_apps.service_workers`<br>
UNION ALL<br>
SELECT<br>
DISTINCT date,<br>
pwa_url<br>
FROM<br>
`progressive_web_apps.usecounters_pwas`)<br>
GROUP BY<br>
date<br>
ORDER BY<br>
date;</p>
<p><img src="img/0__gNSVMzRToj6wLazJ.png" alt=""></p>
<h3>Future Work and Conclusions</h3>
<p>In this document, we have presented three different approaches to extracting PWA data from the HTTP Archive. Each has its individual pros and cons, but especially <em>Approach 3</em> has proven very interesting as a basis for further analyses. All presented queries are ‚Äúevergreen‚Äù in a sense that they are not tied to a particular crawl‚Äôs tables, allowing for ongoing analyses also in the future. Depending on people‚Äôs interest, we will see to what extent the data can be made generally available as part of the HTTP Archive‚Äôs public tables. There are likewise interesting research opportunities by combining our results with the <a href="https://developers.google.com/web/tools/chrome-user-experience-report/">Chrome User Experience Report</a> that is also <a href="https://developers.google.com/web/tools/chrome-user-experience-report/getting-started#query-dataset">accessible with BigQuery</a>. Concluding, the overall trends show in the right direction. More and more pages are controlled by a service worker, leading to PWAs with a generally increasing Lighthouse PWA score. Something to watch out for is the decline in PWAs observed in the <em>Meta Approach</em>, which, however, is not reflected in the most precise and neutral <em>Approach 2</em>, where rather the opposite is the case. We look forward to learning about new ways people make use of our research and to PWAs becoming more and more mainstream.</p>
<h3>Acknowledgements</h3>
<p>In no particular order we would like to thank <a href="https://twitter.com/mathias">Mathias Bynens</a> for help with shaping one of the initial queries, <a href="https://twitter.com/kenjibaheux">Kenji Baheux</a> for pointers that led to <em>Approach 2</em>, <a href="https://twitter.com/rick_viscomi">Rick Viscomi</a> and <a href="https://twitter.com/patmeenan?lang=en">Patrick Meenan</a> for general HTTP Archive help and the video series, <a href="https://twitter.com/jeffposnick">Jeff Posnick</a>, <a href="https://twitter.com/ade_oshineye">Ade Oshineye</a>, <a href="https://twitter.com/igrigorik">Ilya Grigorik</a>, <a href="https://twitter.com/JohnMu">John Mueller</a>, <a href="https://twitter.com/cheneytsai?lang=en">Cheney Tsai</a>, <a href="https://twitter.com/mcmd">Miguel Carlos Mart√≠nez D√≠az</a>, and <a href="https://twitter.com/ebidel">Eric Bidelman</a> for editorial comments, as well as <a href="https://twitter.com/falkenmatto?lang=en">Matt Falkenhagen</a> and <a href="https://twitter.com/mgiuca">Matt Giuca</a> for providing technical background on use counters.</p>
