<h3>TL;DR</h3>
<p>Instead of purely relying on URL-based pattern matching, also consider leveraging the lesser-known — but super useful — <code>[Request.destination](https://developer.mozilla.org/en-US/docs/Web/API/Request/destination)</code> property in your service worker to determine the type and/or caching strategy of requests. Note, though, that <code>Request.destination</code> gets set to the non-informative empty string default value for <code>XMLHttpRequest</code> or <code>fetch()</code> calls. You can play with the <code>[Request.destination](https://request-destination-playground.glitch.me/)</code><a href="https://request-destination-playground.glitch.me/">playground app</a> to see <code>Request.destination</code> in action.</p>
<h3>Different Caching Strategies for Different Types of Resources</h3>
<p>When it comes to establishing caching strategies for Progressive Web Apps, not all resources should be treated equally. For example, for a shopping PWA, your API calls that return live data on some items’ availabilities might be configured to use a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only">Network Only</a> strategy, your self-hosted company-owned web fonts might be configured to use a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only">Cache Only</a> strategy, and your other HTML, CSS, JavaScript, and image resources might use a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache">Network Falling Back to Cache</a> strategy.</p>
<h3>URL-based Determination of the Request Type</h3>
<p>Commonly, developers have relied on the known URL structure of their PWAs and regular expressions to determine the appropriate caching strategy for a given request. For example, here’s an excerpt of a modified code snippet courtesy of <a href="https://twitter.com/jaffathecake">Jake Archibald</a>’s <a href="https://jakearchibald.com/2014/offline-cookbook/">offline cookbook</a>:</p>
<p>// In serviceworker.js<br>
self.addEventListener('fetch', (event) =&gt; {<br>
// Parse the URL<br>
const requestURL = new URL(event.request.url);</p>
<p>// Handle article URLs<br>
if (/^<strong>\/<strong>article</strong>\/</strong>/.test(requestURL.pathname)) {<br>
event.respondWith(/* some response strategy */);<br>
return;<br>
}<br>
if (/**\.**webp$/.test(requestURL.pathname)) {<br>
event.respondWith(/* some other response strategy */);<br>
return;<br>
}<br>
/* … */<br>
});</p>
<p>This approach allows developers to deal with their <a href="https://developers.google.com/speed/webp/">WebP images</a> (<em>i.e.</em>, requests that match the regular expression <code>/\.webp$/</code>) differently than with their HTML articles (<em>i.e.</em>, requests that match <code>/^\/article\//</code>). The downside of this approach is that it makes hard-coded assumptions about the URL structure of a PWA or the used MIME types’ file extensions, which creates a tight coupling between app and service worker logic. Should you move away from WebP to a future superior image format, you would need to remember to update your service worker’s logic as well.</p>
<h3><code>Request.destination</code>-based Determination of the Request Type</h3>
<p>It turns out, the platform has a built-in way for determining the type of a request: it’s called <code>[Request.destination](https://fetch.spec.whatwg.org/#concept-request-destination)</code> as specified in the <a href="https://fetch.spec.whatwg.org/">Fetch Standard</a>. Quoting straight from the spec:</p>
<blockquote>
<p><em>“A request has an associated destination, which is the empty string,</em> <code>_&quot;audio&quot;_</code><em>,</em> <code>_&quot;audioworklet&quot;_</code><em>,</em> <code>_&quot;document&quot;_</code><em>,</em> <code>_&quot;embed&quot;_</code><em>,</em> <code>_&quot;font&quot;_</code><em>,</em> <code>_&quot;image&quot;_</code><em>,</em> <code>_&quot;manifest&quot;_</code><em>,</em> <code>_&quot;object&quot;_</code><em>,</em> <code>_&quot;paintworklet&quot;_</code><em>,</em> <code>_&quot;report&quot;_</code><em>,</em> <code>_&quot;script&quot;_</code><em>,</em> <code>_&quot;serviceworker&quot;_</code><em>,</em> <code>_&quot;sharedworker&quot;_</code><em>,</em> <code>_&quot;style&quot;_</code><em>,</em> <code>_&quot;track&quot;_</code><em>,</em> <code>_&quot;video&quot;_</code><em>,</em> <code>_&quot;worker&quot;_</code><em>, or</em> <code>_&quot;xslt&quot;_</code><em>. Unless stated otherwise it is the empty string.”</em></p>
</blockquote>
<p>The empty string default value is the biggest caveat. Essentially, you can’t determine the type of resources that are requested via the following methods:</p>
<blockquote>
<p><code>[_navigator.sendBeacon()_](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon)</code><em>,</em> <code>[_EventSource_](https://developer.mozilla.org/en-US/docs/Web/API/EventSource)</code><em>, HTML’s</em> <code>[_&lt;a ping=&quot;&quot;&gt;_](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-ping)</code> <em>and</em> <code>[_&lt;area ping=&quot;&quot;&gt;_](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area#attr-ping)</code><em>,</em> <code>[_fetch()_](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)</code><em>,</em> <code>[_XMLHttpRequest_](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)</code><em>,</em> <code>[_WebSocket_](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)</code><em>, [and the]</em> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache"><em>Cache API</em></a></p>
</blockquote>
<p>In practice having <code>Request.destination</code> get set to the non-informative empty string default value matters the most for <code>fetch()</code> and <code>XMLHttpRequest</code>, so at least for resources requested through these techniques, it’s oftentimes back to URL-based pattern handling inside your service worker.</p>
<p>On the bright side, you can determine the type of everything else perfectly fine. I have built a little <code>[Request.destination](https://request-destination-playground.glitch.me/)</code><a href="https://request-destination-playground.glitch.me/">playground app</a> that shows some of these destinations in action. Note that for the sake of the to-be-demonstrated effect it also contains some anti-patterns like <a href="https://developers.google.com/web/fundamentals/primers/service-workers/registration">registering the service worker</a> as early as possible and actively circumventing the browser’s preloading heuristics (never do this in production).</p>
<p><img src="img/0__p48NZ4RlIY12313C.jpg" alt=" playground app showing different request types">
<code>_Request.destination_</code> <em>playground app showing different request types</em></p>
<p>When you think about it, there are a huge number of ways a page can request resources to load. A <code>&lt;video&gt;</code> can load an image as its poster frame and a timed text track file via <code>&lt;track&gt;</code>, apart from the video bytes it obviously loads. A stylesheet can cause images to load that are used somewhere on the page as background images, as well as web fonts. An <code>&lt;iframe&gt;</code> loads an HTML document. Oh, and the HTML document itself can load manifests, stylesheets, scripts, images, and a ton of other elements like <code>&lt;object&gt;</code> that was quite popular in the past to load Flash movies.</p>
<p><img src="img/0____mNfZCkVVBwp6TD2.jpg" alt="An , two s with background images and triggers for  or , an , and a  with poster image and timed text track">
<em>An</em> <code>_&lt;img&gt;_</code><em>, two</em> <code>_&lt;p&gt;_</code><em>s with background images and triggers for</em> <code>_XMLHttpRequest_</code> <em>or</em> <code>_fetch()_</code><em>, an</em> <code>_&lt;iframe&gt;_</code><em>, and a</em> <code>_&lt;video&gt;_</code> <em>with poster image and timed text track</em></p>
<p>Coming back to the initial example of the shopping PWA, we could come up with a simple service worker router as outlined in the code below. This router is completely agnostic of the URL structure, so there’s no tight coupling at all.</p>
<p>// In serviceworker.js<br>
self.addEventListener('fetch', (event) =&gt; {<br>
const destination = event.request.destination;<br>
switch (destination) {<br>
case 'style':<br>
case 'script':<br>
case 'document':<br>
case 'image': {<br>
event.respondWith(<br>
/* &quot;Network Falling Back to Cache&quot; strategy */);<br>
return;<br>
}<br>
case 'font': {<br>
event.respondWith(/* &quot;Cache Only&quot; strategy */);<br>
return;<br>
}<br>
// All `XMLHttpRequest` or `fetch()` calls where<br>
// `Request.destination` is the empty string default value<br>
default: {<br>
event.respondWith(/* &quot;Network Only&quot; strategy */);<br>
return;<br>
}<br>
}<br>
});</p>
<h3>Browser Support for <code>Request.destination</code></h3>
<p><code>Request.destination</code> is universally supported by Chrome, Opera, Firefox, Safari, and Edge. For Chrome, support was added in Chrome 65, so for the unlikely case where your target audience uses older browsers than that, you might want to be careful with fully relying on this feature for your router. Other than that, <code>Request.destination</code> is ready for business. You can see the full details on the corresponding <a href="https://www.chromestatus.com/feature/5629697845100544">Chrome Platform Status page</a>.</p>
<h3>When <code>Request.destination</code> isn’t Enough</h3>
<p>If you have more complex caching needs, you will soon realize that <em>purely</em> relying on <code>Request.destination</code> is <em>not</em> enough. For example, all your stylesheets may indeed use the same response strategy (and thus be good candidates for <code>Request.destination</code>), however, your HTML documents or API requests might still require different caching logic the more advanced your app gets.</p>
<p>Fortunately, you can freely combine <code>Request.destination</code> with URL-based pattern matching, there’s absolutely no harm in doing so. A basic example could be to use <code>Request.destination</code> for dealing with all kinds of images to return a default offline fallback placeholder, and to use <code>Request.url</code> with URL-based pattern matching for other resources. You can likewise decide to have different behavior based on the <code>Request.mode</code> of the request, for instance to check if you are dealing with a navigational request (<code>Request.mode === 'navigate'</code>) in single-page apps.</p>
<h3>Conclusion</h3>
<p>Coming up with a reasonable caching strategy for a PWA is hard enough. Having ways to tame this complexity is definitely welcome, so whenever feasible — given your PWA’s structure — in addition to URL-based pattern handling, also consider leveraging <code>Request.destination</code> for your service worker’s routing logic. It may not be able to handle all routes and there are important exceptions and corner cases, but it’s definitely a good idea to reduce the coupling of service worker logic and URL structure as much as possible.</p>
<h3>Acknowledgements</h3>
<p>Thanks to <a href="https://twitter.com/mathias">Mathias Bynens</a>, <a href="https://twitter.com/jeffposnick">Jeff Posnick</a>, <a href="https://twitter.com/addyosmani">Addy Osmani</a>, <a href="https://twitter.com/rowan_m">Rowan Merewood</a>, and <a href="https://twitter.com/ialbmedina">Alberto Medina</a> for reviewing this article, and again Mathias for his help with debugging emoji encoding in Edge!</p>
